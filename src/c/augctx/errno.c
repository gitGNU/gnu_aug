/*
  Copyright (c) 2004-2009, Mark Aylett <mark.aylett@gmail.com>

  This file is part of Aug written by Mark Aylett.

  Aug is released under the GPL with the additional exemption that compiling,
  linking, and/or using OpenSSL is allowed.

  Aug is free software; you can redistribute it and/or modify it under the
  terms of the GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any later
  version.

  Aug is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  You should have received a copy of the GNU General Public License along with
  this program; if not, write to the Free Software Foundation, Inc., 51
  Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
#define AUGCTX_BUILD
#include "augctx/errno.h"
#include "augctx/defs.h"

AUG_RCSID("$Id$");

#if defined(_WIN32)

#include <winsock2.h>

struct errormap_ {
    unsigned long win32_;
    int errno_;
};

static const struct errormap_ ERRORMAP_[] = {
    { ERROR_INVALID_FUNCTION, EINVAL },
    { ERROR_FILE_NOT_FOUND, ENOENT },
    { ERROR_PATH_NOT_FOUND, ENOENT },
    { ERROR_TOO_MANY_OPEN_FILES, EMFILE },
    { ERROR_ACCESS_DENIED, EACCES },
    { ERROR_INVALID_HANDLE, EBADF },
    { ERROR_ARENA_TRASHED, ENOMEM },
    { ERROR_NOT_ENOUGH_MEMORY, ENOMEM },
    { ERROR_INVALID_BLOCK, ENOMEM },
    { ERROR_BAD_ENVIRONMENT, E2BIG },
    { ERROR_BAD_FORMAT, ENOEXEC },
    { ERROR_INVALID_ACCESS, EINVAL },
    { ERROR_INVALID_DATA, EINVAL },
    { ERROR_INVALID_DRIVE, ENOENT },
    { ERROR_CURRENT_DIRECTORY, EACCES },
    { ERROR_NOT_SAME_DEVICE, EXDEV },
    { ERROR_NO_MORE_FILES, ENOENT },
    { ERROR_LOCK_VIOLATION, EACCES },
    { ERROR_BAD_NETPATH, ENOENT },
    { ERROR_NETWORK_ACCESS_DENIED, EACCES },
    { ERROR_BAD_NET_NAME, ENOENT },
    { ERROR_FILE_EXISTS, EEXIST },
    { ERROR_CANNOT_MAKE, EACCES },
    { ERROR_FAIL_I24, EACCES },
    { ERROR_INVALID_PARAMETER, EINVAL },
    { ERROR_NO_PROC_SLOTS, EAGAIN },
    { ERROR_DRIVE_LOCKED, EACCES },
    { ERROR_BROKEN_PIPE, EPIPE },
    { ERROR_DISK_FULL, ENOSPC },
    { ERROR_INVALID_TARGET_HANDLE, EBADF },
    { ERROR_INVALID_HANDLE, EINVAL },
    { ERROR_WAIT_NO_CHILDREN, ECHILD },
    { ERROR_CHILD_NOT_COMPLETE, ECHILD },
    { ERROR_DIRECT_ACCESS_HANDLE, EBADF },
    { ERROR_NEGATIVE_SEEK, EINVAL },
    { ERROR_SEEK_ON_DEVICE, EACCES },
    { ERROR_DIR_NOT_EMPTY, ENOTEMPTY },
    { ERROR_NOT_LOCKED, EACCES },
    { ERROR_BAD_PATHNAME, ENOENT },
    { ERROR_MAX_THRDS_REACHED, EAGAIN },
    { ERROR_LOCK_FAILED, EACCES },
    { ERROR_ALREADY_EXISTS, EEXIST },
    { ERROR_FILENAME_EXCED_RANGE, ENOENT },
    { ERROR_NESTING_NOT_ALLOWED, EAGAIN },
    { ERROR_NOT_ENOUGH_QUOTA, ENOMEM },
    { WSAEINTR, EINTR },
    { WSAEBADF, EBADF },
    { WSAEACCES, EACCES },
    { WSAEFAULT, EFAULT },
    { WSAEINVAL, EINVAL },
    { WSAEMFILE, EMFILE },
    { WSAEWOULDBLOCK, EWOULDBLOCK },
    { WSAEINPROGRESS, EINPROGRESS },
    { WSAEALREADY, EALREADY },
    { WSAENOTSOCK, ENOTSOCK },
    { WSAEDESTADDRREQ, EDESTADDRREQ },
    { WSAEMSGSIZE, EMSGSIZE },
    { WSAEPROTOTYPE, EPROTOTYPE },
    { WSAENOPROTOOPT, ENOPROTOOPT },
    { WSAEPROTONOSUPPORT, EPROTONOSUPPORT },
    { WSAESOCKTNOSUPPORT, ESOCKTNOSUPPORT },
    { WSAEOPNOTSUPP, EOPNOTSUPP },
    { WSAEPFNOSUPPORT, EPFNOSUPPORT },
    { WSAEAFNOSUPPORT, EAFNOSUPPORT },
    { WSAEADDRINUSE, EADDRINUSE },
    { WSAEADDRNOTAVAIL, EADDRNOTAVAIL },
    { WSAENETDOWN, ENETDOWN },
    { WSAENETUNREACH, ENETUNREACH },
    { WSAENETRESET, ENETRESET },
    { WSAECONNABORTED, ECONNABORTED },
    { WSAECONNRESET, ECONNRESET },
    { WSAENOBUFS, ENOBUFS },
    { WSAEISCONN, EISCONN },
    { WSAENOTCONN, ENOTCONN },
    { WSAESHUTDOWN, ESHUTDOWN },
    { WSAETOOMANYREFS, ETOOMANYREFS },
    { WSAETIMEDOUT, ETIMEDOUT },
    { WSAECONNREFUSED, ECONNREFUSED },
    { WSAELOOP, ELOOP },
    { WSAENAMETOOLONG, ENAMETOOLONG },
    { WSAEHOSTDOWN, EHOSTDOWN },
    { WSAEHOSTUNREACH, EHOSTUNREACH },
    { WSAENOTEMPTY, ENOTEMPTY },
    { WSAEPROCLIM, EPROCLIM },
    { WSAEUSERS, EUSERS },
    { WSAEDQUOT, ENOMEM },
    { WSAESTALE, ESTALE },
    { WSASYSNOTREADY, ESYSNOTREADY },
    { WSAVERNOTSUPPORTED, EVERNOTSUPPORTED },
    { WSANOTINITIALISED, ENOTINITIALISED },
    { WSAEREMOTE, EREMOTE },
    { WSAEDISCON, EDISCON },
    { WSAHOST_NOT_FOUND, EHOSTNOTFOUND },
    { WSATRY_AGAIN, ETRYAGAIN },
    { WSANO_RECOVERY, ENORECOVERY },
    { WSANO_DATA, ENODATA },
    { WSA_INVALID_HANDLE, EBADF },
    { WSA_INVALID_PARAMETER, EINVAL },
    { WSA_IO_INCOMPLETE, EIOINCOMPLETE },
    { WSA_IO_PENDING, EIOPENDING },
    { WSA_NOT_ENOUGH_MEMORY, ENOMEM },
    { WSA_OPERATION_ABORTED, EOPERATIONABORTED }
};

#define ERRORMAP_SIZE_ (sizeof(ERRORMAP_) / sizeof(ERRORMAP_[0]))

#define ENOEXEC_BEGIN_ ERROR_INVALID_STARTING_CODESEG
#define ENOEXEC_END_ ERROR_INFLOOP_IN_RELOC_CHAIN

#define EACCES_BEGIN_ ERROR_WRITE_PROTECT
#define EACCES_END_ ERROR_SHARING_BUFFER_EXCEEDED

AUGCTX_API int
aug_win32posix(unsigned long win32)
{
    int i;
    if (0 == win32)
        return 0;

    for (i = 0; ERRORMAP_SIZE_ > i; ++i)
        if (win32 == ERRORMAP_[i].win32_)
            return ERRORMAP_[i].errno_;

    if (EACCES_BEGIN_ <= win32 && EACCES_END_ >= win32)
        return EACCES;

    if (ENOEXEC_BEGIN_ <= win32 && ENOEXEC_END_ >= win32)
        return ENOEXEC;

    return EINVAL;
}

#endif /* _WIN32 */
