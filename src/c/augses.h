/* -*- c++ -*- */
/* Automatically generated by augidl */
/* at Thu Nov 05 07:16:16 +0000 2009 */

#ifndef AUGSES_H
#define AUGSES_H

#include "augabi.h"

#if defined(__cplusplus)

#include "augabipp.hpp"

namespace aug {
    template <typename T>
    struct object_traits;
}

#endif /* __cplusplus */

/* Includes. */

#include "augmod.h"

/* Interface declarations. */

AUG_INTERFACE(mod_session);

/* Interface definitions. */

/**
 * @defgroup mod_session mod_session
 *
 * @ingroup Object
 *
 * @{
 */

/**
 * Session functions of type mod_bool should return either #MOD_TRUE or
 * #MOD_FALSE, depending on the result.  For those functions associated with
 * a connection, a false return will result in the connection being closed.
 */

struct mod_sessionvtbl {
    AUG_VTBL(mod_session);
    mod_bool (*start_)(mod_session*);
    void (*stop_)(mod_session*);
    void (*reconf_)(mod_session*);
    void (*event_)(mod_session*, const char*, const char*, mod_id, aug_object*);
    void (*closed_)(mod_session*, struct mod_handle*);
    void (*teardown_)(mod_session*, struct mod_handle*);
    mod_bool (*accepted_)(mod_session*, struct mod_handle*, const char*);
    void (*connected_)(mod_session*, struct mod_handle*, const char*);
    mod_bool (*auth_)(mod_session*, struct mod_handle*, const char*, const char*);
    void (*recv_)(mod_session*, struct mod_handle*, const void*, size_t);
    void (*mrecv_)(mod_session*, const char*, unsigned, unsigned short, const void*, size_t);
    void (*error_)(mod_session*, struct mod_handle*, const char*);
    void (*rdexpire_)(mod_session*, struct mod_handle*, unsigned*);
    void (*wrexpire_)(mod_session*, struct mod_handle*, unsigned*);
    void (*expire_)(mod_session*, struct mod_handle*, unsigned*);
};

/**
 * Start session.
 * Non-trivial resource acquisition and construction.  Two-phase
 * construction is required to allow callbacks during the method
 * invocation.
 * @param this_ The object.
 * @return Either #MOD_TRUE or #MOD_FALSE.
 */

#define mod_start(this_) \
    (this_)->vtbl_->start_(this_)

/**
 * Stop session.
 * All resources associated with the session should be released.  stop()
 * will only be called for a session if start() returned #MOD_TRUE.
 */

#define mod_stop(this_) \
    (this_)->vtbl_->stop_(this_)

/**
 * Re-configure request.
 * Called in response to a #AUG_EVENTRECONF event, which are raise in
 * response to either a #SIGHUP, or a call to mod_host::reconfall_().
 */

#define mod_reconf(this_) \
    (this_)->vtbl_->reconf_(this_)

/**
 * Custom event notification.
 * @param this_ The object.
 * @param from Source session name.
 * @param type Event type.
 * @param id Event descriptor.
 * @param ob Optional object data.
 */

#define mod_event(this_, from, type, id, ob) \
    (this_)->vtbl_->event_(this_, from, type, id, ob)

/**
 * Connection closure.
 * @param this_ The object.
 * @param sock The closed socket.
 */

#define mod_closed(this_, sock) \
    (this_)->vtbl_->closed_(this_, sock)

/**
 * Teardown request.
 * @param this_ The object.
 * @param sock Socket descriptor.
 */

#define mod_teardown(this_, sock) \
    (this_)->vtbl_->teardown_(this_, sock)

/**
 * Acceptance of socket connection.
 * This function is called when a new connection is accepted on a listener
 * socket.
 * @param this_ The object.
 * @param sock Socket descriptor.
 * @param name Peer address.
 * @return Either #MOD_TRUE or #MOD_FALSE.
 */

#define mod_accepted(this_, sock, name) \
    (this_)->vtbl_->accepted_(this_, sock, name)

/**
 * Completion of client connection handshake.
 * This function is called when a connection, initiated by a call to
 * mod_host::tcpconnect_(), becomes established.
 * @param this_ The object.
 * @param sock Socket descriptor.
 * @param name Peer address.
 * @see mod_host::tcpconnect_().
 */

#define mod_connected(this_, sock, name) \
    (this_)->vtbl_->connected_(this_, sock, name)

/**
 * Authorisation of peer certificate.
 * @param this_ The object.
 * @param sock Socket descriptor.
 * @param subject Certificate subject.
 * @param issuer Certificate issuer.
 * @return Either #MOD_TRUE or #MOD_FALSE.
 */

#define mod_auth(this_, sock, subject, issuer) \
    (this_)->vtbl_->auth_(this_, sock, subject, issuer)

/**
 * Inbound data.
 * @param this_ The object.
 * @param sock The socket on which the data was received.
 * @param buf Data buffer.  May not be null terminated.
 * @param len Length of data buffer.
 */

#define mod_recv(this_, sock, buf, len) \
    (this_)->vtbl_->recv_(this_, sock, buf, len)

/**
 * Inbound cluster packet.
 * @param this_ The object.
 * @param node Originating node.
 * @param sess Node's session identifier.
 * @param type Packet type.
 * @param buf Data buffer.  May not be null terminated.
 * @param len Length of data buffer.
 */

#define mod_mrecv(this_, node, sess, type, buf, len) \
    (this_)->vtbl_->mrecv_(this_, node, sess, type, buf, len)

/**
 * Connection error.
 * @param this_ The object.
 * @param sock The closed socket.
 * @param desc Error description.
 */

#define mod_error(this_, sock, desc) \
    (this_)->vtbl_->error_(this_, sock, desc)

/**
 * Expiry of read timer.
 * @param this_ The object.
 * @param sock Socket descriptor.
 * @param ms The current timeout value.  The callee may modify @a ms to
 * specify a new value; a value of zero will cancel the timer.
 */

#define mod_rdexpire(this_, sock, ms) \
    (this_)->vtbl_->rdexpire_(this_, sock, ms)

/**
 * Expiry of write timer.
 * @param this_ The object.
 * @param sock Socket descriptor.
 * @param ms The current timeout value.  The callee may modify @a ms to
 * specify a new value; a value of zero will cancel the timer.
 */

#define mod_wrexpire(this_, sock, ms) \
    (this_)->vtbl_->wrexpire_(this_, sock, ms)

/**
 * Timer expiry.
 * @param this_ The object.
 * @param timer Timer handle.
 * @param ms The current timeout value.  The callee may modify @a ms to
 * specify a new value; a value of zero will cancel the timer.
 */

#define mod_expire(this_, timer, ms) \
    (this_)->vtbl_->expire_(this_, timer, ms)

/** @} */

#if defined(__cplusplus)
namespace aug {
    template <>
    struct object_traits<mod_session> {
        typedef mod_sessionvtbl vtbl;
        static const char*
        id() AUG_NOTHROW
        {
            return mod_sessionid;
        }
    };
}

namespace mod {

    template <typename T>
    class session {

        mod_session session_;

        session(const session&);

        session&
        operator =(const session&);

        static void*
        cast_(mod_session* this_, const char* id) AUG_NOTHROW
        {
            return aug::retget(static_cast<T*>(this_->impl_)->cast_(id));
        }
        static void
        retain_(mod_session* this_) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->retain_();
        }
        static void
        release_(mod_session* this_) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->release_();
        }
        static mod_bool
        start_(mod_session* this_) AUG_NOTHROW
        {
            return static_cast<T*>(this_->impl_)->start_();
        }
        static void
        stop_(mod_session* this_) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->stop_();
        }
        static void
        reconf_(mod_session* this_) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->reconf_();
        }
        static void
        event_(mod_session* this_, const char* from, const char* type, mod_id id, aug_object* ob) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->event_(from, type, id, ob);
        }
        static void
        closed_(mod_session* this_, struct mod_handle* sock) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->closed_(*sock);
        }
        static void
        teardown_(mod_session* this_, struct mod_handle* sock) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->teardown_(*sock);
        }
        static mod_bool
        accepted_(mod_session* this_, struct mod_handle* sock, const char* name) AUG_NOTHROW
        {
            return static_cast<T*>(this_->impl_)->accepted_(*sock, name);
        }
        static void
        connected_(mod_session* this_, struct mod_handle* sock, const char* name) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->connected_(*sock, name);
        }
        static mod_bool
        auth_(mod_session* this_, struct mod_handle* sock, const char* subject, const char* issuer) AUG_NOTHROW
        {
            return static_cast<T*>(this_->impl_)->auth_(*sock, subject, issuer);
        }
        static void
        recv_(mod_session* this_, struct mod_handle* sock, const void* buf, size_t len) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->recv_(*sock, buf, len);
        }
        static void
        mrecv_(mod_session* this_, const char* node, unsigned sess, unsigned short type, const void* buf, size_t len) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->mrecv_(node, sess, type, buf, len);
        }
        static void
        error_(mod_session* this_, struct mod_handle* sock, const char* desc) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->error_(*sock, desc);
        }
        static void
        rdexpire_(mod_session* this_, struct mod_handle* sock, unsigned* ms) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->rdexpire_(*sock, *ms);
        }
        static void
        wrexpire_(mod_session* this_, struct mod_handle* sock, unsigned* ms) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->wrexpire_(*sock, *ms);
        }
        static void
        expire_(mod_session* this_, struct mod_handle* timer, unsigned* ms) AUG_NOTHROW
        {
            static_cast<T*>(this_->impl_)->expire_(*timer, *ms);
        }
        static const mod_sessionvtbl*
        vtbl()
        {
            static const mod_sessionvtbl local = {
                cast_,
                retain_,
                release_,
                start_,
                stop_,
                reconf_,
                event_,
                closed_,
                teardown_,
                accepted_,
                connected_,
                auth_,
                recv_,
                mrecv_,
                error_,
                rdexpire_,
                wrexpire_,
                expire_
            };
            return &local;
        }
    public:
        explicit
        session(T* impl = 0)
        {
            this->session_.vtbl_ = this->vtbl();
            this->session_.impl_ = impl;
        }
        void
        reset(T* impl)
        {
            this->session_.impl_ = impl;
        }
        mod_session*
        get() AUG_NOTHROW
        {
            return &this->session_;
        }
        operator aug::obref<mod_session>() AUG_NOTHROW
        {
            return this->get();
        }
    };

    typedef aug::obref<mod_session> sessionref;
    typedef aug::smartob<mod_session> sessionptr;
}
#endif /* __cplusplus */

/* C++ definitions. */

#if defined(__cplusplus)
namespace mod {

    inline mod_bool
    start(aug::obref<mod_session> this_) AUG_NOTHROW
    {
        return this_.get()->vtbl_->start_(this_.get());
    }

    inline void
    stop(aug::obref<mod_session> this_) AUG_NOTHROW
    {
        this_.get()->vtbl_->stop_(this_.get());
    }

    inline void
    reconf(aug::obref<mod_session> this_) AUG_NOTHROW
    {
        this_.get()->vtbl_->reconf_(this_.get());
    }

    inline void
    event(aug::obref<mod_session> this_, const char* from, const char* type, mod_id id, aug::obref<aug_object> ob) AUG_NOTHROW
    {
        this_.get()->vtbl_->event_(this_.get(), from, type, id, ob.get());
    }

    inline void
    closed(aug::obref<mod_session> this_, struct mod_handle& sock) AUG_NOTHROW
    {
        this_.get()->vtbl_->closed_(this_.get(), &sock);
    }

    inline void
    teardown(aug::obref<mod_session> this_, struct mod_handle& sock) AUG_NOTHROW
    {
        this_.get()->vtbl_->teardown_(this_.get(), &sock);
    }

    inline mod_bool
    accepted(aug::obref<mod_session> this_, struct mod_handle& sock, const char* name) AUG_NOTHROW
    {
        return this_.get()->vtbl_->accepted_(this_.get(), &sock, name);
    }

    inline void
    connected(aug::obref<mod_session> this_, struct mod_handle& sock, const char* name) AUG_NOTHROW
    {
        this_.get()->vtbl_->connected_(this_.get(), &sock, name);
    }

    inline mod_bool
    auth(aug::obref<mod_session> this_, struct mod_handle& sock, const char* subject, const char* issuer) AUG_NOTHROW
    {
        return this_.get()->vtbl_->auth_(this_.get(), &sock, subject, issuer);
    }

    inline void
    recv(aug::obref<mod_session> this_, struct mod_handle& sock, const void* buf, size_t len) AUG_NOTHROW
    {
        this_.get()->vtbl_->recv_(this_.get(), &sock, buf, len);
    }

    inline void
    mrecv(aug::obref<mod_session> this_, const char* node, unsigned sess, unsigned short type, const void* buf, size_t len) AUG_NOTHROW
    {
        this_.get()->vtbl_->mrecv_(this_.get(), node, sess, type, buf, len);
    }

    inline void
    error(aug::obref<mod_session> this_, struct mod_handle& sock, const char* desc) AUG_NOTHROW
    {
        this_.get()->vtbl_->error_(this_.get(), &sock, desc);
    }

    inline void
    rdexpire(aug::obref<mod_session> this_, struct mod_handle& sock, unsigned& ms) AUG_NOTHROW
    {
        this_.get()->vtbl_->rdexpire_(this_.get(), &sock, &ms);
    }

    inline void
    wrexpire(aug::obref<mod_session> this_, struct mod_handle& sock, unsigned& ms) AUG_NOTHROW
    {
        this_.get()->vtbl_->wrexpire_(this_.get(), &sock, &ms);
    }

    inline void
    expire(aug::obref<mod_session> this_, struct mod_handle& timer, unsigned& ms) AUG_NOTHROW
    {
        this_.get()->vtbl_->expire_(this_.get(), &timer, &ms);
    }

    template <typename T>
    class session_base {
        session<T> session_;
        int refs_;
    protected:
        ~session_base()
        {
            /* Always deleted via derived, so no need to be virtual. */
        }
        session_base()
            : refs_(1)
        {
            this->session_.reset(static_cast<T*>(this));
        }
    public:
        aug::smartob<aug_object>
        cast_(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<mod_session>(id))
                return aug::object_retain<aug_object>(this->session_);
            return null;
        }
        void
        retain_() AUG_NOTHROW
        {
            assert(0 < this->refs_);
            ++this->refs_;
        }
        void
        release_() AUG_NOTHROW
        {
            assert(0 < this->refs_);
            if (0 == --this->refs_)
                delete static_cast<T*>(this);
        }
        static aug::smartob<mod_session>
        attach(T* ptr)
        {
            return aug::object_attach<mod_session>(ptr->session_);
        }
    };

    template <typename T>
    class scoped_session_base {
        session<T> session_;
    protected:
        ~scoped_session_base()
        {
        }
        scoped_session_base()
        {
            this->session_.reset(static_cast<T*>(this));
        }
    public:
        aug::smartob<aug_object>
        cast_(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<mod_session>(id))
                return aug::object_retain<aug_object>(this->session_);
            return null;
        }
        void
        retain_() AUG_NOTHROW
        {
        }
        void
        release_() AUG_NOTHROW
        {
        }
        aug_object*
        base() AUG_NOTHROW
        {
            return aug::obref<aug_object>(this->session_).get();
        }
        mod_session*
        get() AUG_NOTHROW
        {
            return this->session_.get();
        }
        operator aug::obref<mod_session>() AUG_NOTHROW
        {
            return this->session_;
        }
    };

    template <typename T>
    class session_wrapper {
        session<session_wrapper<T> > session_;
        T impl_;
        int refs_;
        explicit
        session_wrapper(const T& impl)
            : impl_(impl),
              refs_(1)
        {
            this->session_.reset(this);
        }
    public:
        aug::smartob<aug_object>
        cast_(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<mod_session>(id))
                return aug::object_retain<aug_object>(this->session_);
            return null;
        }
        void
        retain_() AUG_NOTHROW
        {
            assert(0 < this->refs_);
            ++this->refs_;
        }
        void
        release_() AUG_NOTHROW
        {
            assert(0 < this->refs_);
            if (0 == --this->refs_)
                delete this;
        }
        mod_bool
        start_() AUG_NOTHROW
        {
            return this->impl_.start_();
        }
        void
        stop_() AUG_NOTHROW
        {
            this->impl_.stop_();
        }
        void
        reconf_() AUG_NOTHROW
        {
            this->impl_.reconf_();
        }
        void
        event_(const char* from, const char* type, mod_id id, aug::obref<aug_object> ob) AUG_NOTHROW
        {
            this->impl_.event_(from, type, id, ob);
        }
        void
        closed_(struct mod_handle& sock) AUG_NOTHROW
        {
            this->impl_.closed_(sock);
        }
        void
        teardown_(struct mod_handle& sock) AUG_NOTHROW
        {
            this->impl_.teardown_(sock);
        }
        mod_bool
        accepted_(struct mod_handle& sock, const char* name) AUG_NOTHROW
        {
            return this->impl_.accepted_(sock, name);
        }
        void
        connected_(struct mod_handle& sock, const char* name) AUG_NOTHROW
        {
            this->impl_.connected_(sock, name);
        }
        mod_bool
        auth_(struct mod_handle& sock, const char* subject, const char* issuer) AUG_NOTHROW
        {
            return this->impl_.auth_(sock, subject, issuer);
        }
        void
        recv_(struct mod_handle& sock, const void* buf, size_t len) AUG_NOTHROW
        {
            this->impl_.recv_(sock, buf, len);
        }
        void
        mrecv_(const char* node, unsigned sess, unsigned short type, const void* buf, size_t len) AUG_NOTHROW
        {
            this->impl_.mrecv_(node, sess, type, buf, len);
        }
        void
        error_(struct mod_handle& sock, const char* desc) AUG_NOTHROW
        {
            this->impl_.error_(sock, desc);
        }
        void
        rdexpire_(struct mod_handle& sock, unsigned& ms) AUG_NOTHROW
        {
            this->impl_.rdexpire_(sock, ms);
        }
        void
        wrexpire_(struct mod_handle& sock, unsigned& ms) AUG_NOTHROW
        {
            this->impl_.wrexpire_(sock, ms);
        }
        void
        expire_(struct mod_handle& timer, unsigned& ms) AUG_NOTHROW
        {
            this->impl_.expire_(timer, ms);
        }
        static aug::smartob<mod_session>
        create(const T& impl = T())
        {
            session_wrapper* ptr(new session_wrapper(impl));
            return aug::object_attach<mod_session>(ptr->session_);
        }
    };

    template <typename T>
    class scoped_session_wrapper {
        session<scoped_session_wrapper<T> > session_;
        T impl_;
    public:
        explicit
        scoped_session_wrapper(const T& impl = T())
            : impl_(impl)
        {
            this->session_.reset(this);
        }
        aug::smartob<aug_object>
        cast_(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<mod_session>(id))
                return aug::object_retain<aug_object>(this->session_);
            return null;
        }
        void
        retain_() AUG_NOTHROW
        {
        }
        void
        release_() AUG_NOTHROW
        {
        }
        mod_bool
        start_() AUG_NOTHROW
        {
            return this->impl_.start_();
        }
        void
        stop_() AUG_NOTHROW
        {
            this->impl_.stop_();
        }
        void
        reconf_() AUG_NOTHROW
        {
            this->impl_.reconf_();
        }
        void
        event_(const char* from, const char* type, mod_id id, aug::obref<aug_object> ob) AUG_NOTHROW
        {
            this->impl_.event_(from, type, id, ob);
        }
        void
        closed_(struct mod_handle& sock) AUG_NOTHROW
        {
            this->impl_.closed_(sock);
        }
        void
        teardown_(struct mod_handle& sock) AUG_NOTHROW
        {
            this->impl_.teardown_(sock);
        }
        mod_bool
        accepted_(struct mod_handle& sock, const char* name) AUG_NOTHROW
        {
            return this->impl_.accepted_(sock, name);
        }
        void
        connected_(struct mod_handle& sock, const char* name) AUG_NOTHROW
        {
            this->impl_.connected_(sock, name);
        }
        mod_bool
        auth_(struct mod_handle& sock, const char* subject, const char* issuer) AUG_NOTHROW
        {
            return this->impl_.auth_(sock, subject, issuer);
        }
        void
        recv_(struct mod_handle& sock, const void* buf, size_t len) AUG_NOTHROW
        {
            this->impl_.recv_(sock, buf, len);
        }
        void
        mrecv_(const char* node, unsigned sess, unsigned short type, const void* buf, size_t len) AUG_NOTHROW
        {
            this->impl_.mrecv_(node, sess, type, buf, len);
        }
        void
        error_(struct mod_handle& sock, const char* desc) AUG_NOTHROW
        {
            this->impl_.error_(sock, desc);
        }
        void
        rdexpire_(struct mod_handle& sock, unsigned& ms) AUG_NOTHROW
        {
            this->impl_.rdexpire_(sock, ms);
        }
        void
        wrexpire_(struct mod_handle& sock, unsigned& ms) AUG_NOTHROW
        {
            this->impl_.wrexpire_(sock, ms);
        }
        void
        expire_(struct mod_handle& timer, unsigned& ms) AUG_NOTHROW
        {
            this->impl_.expire_(timer, ms);
        }
        aug_object*
        base() AUG_NOTHROW
        {
            return aug::obref<aug_object>(this->session_).get();
        }
        mod_session*
        get() AUG_NOTHROW
        {
            return this->session_.get();
        }
        operator aug::obref<mod_session>() AUG_NOTHROW
        {
            return this->session_;
        }
    };

    typedef aug::smartob<mod_session> sessionptr;
}
#endif /* __cplusplus */

#endif /* AUGSES_H */
