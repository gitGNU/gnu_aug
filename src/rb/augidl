#!/usr/bin/env ruby
require 'optparse'
require 'rexml/document'

# TODO:
# help attribute.
# getter/setter element.
# object attribute.

include REXML

STDOUT.binmode

class Type
    attr_reader :type
    def initialize(type, object)
        @type = type
        @object = object
    end
    def object?
        @object
    end
end

class Param
    attr_reader :name, :type
    def initialize(name, type)
        @name = name
        @type = type
    end
end

class Method_
    attr_reader :name, :type
    def initialize(name, qname, type)
        @name = name
        @qname = qname
        @type = type
        @params = []
    end
    def each_param(&action)
        @params.each &action
    end
    def push_param(param)
        @params << param
    end
    def qname(iface)
        if @qname.nil? then
            @name + iface
        else
            @qname
        end
    end
end

class Interface
    attr_reader :pkg, :name, :type
    def initialize(pkg, name)
        @pkg = pkg
        @name = name
        @type = Type.new("#{pkg}_#{name}", true)
        @methods = []
    end
    def each_method(&action)
        @methods.each &action
    end
    def push_method(method)
        @methods << method
    end
end

module ParamLists
    def arg_list(iface, method)
        args = ["#{param_type(iface.type)} obj"]
        method.each_param do |param|
            args << "#{param_type(param.type)} #{param.name}"
        end
        args
    end
    def name_list(iface, method)
        args = ["obj"]
        method.each_param do |param|
            args << param.name
        end
        args
    end
    def type_list(iface, method)
        args = [param_type(iface.type)]
        method.each_param do |param|
            args << param_type(param.type)
        end
        args
    end
end

class CFormat
    include ParamLists
    def arg_list(iface, method)
        args = ["#{param_type(iface.type)} obj"]
        method.each_param do |param|
            args << "#{param_type(iface.type)} #{param.name}"
        end
        args
    end
    def name_list(iface, method)
    end
    def type_list(iface, method)
    end
    def param_type(type)
        if type.object? then
            "#{type.type}*"
        else
            type.type
        end
    end
    def return_type(type)
        if type.object? then
            "#{type.type}*"
        else
            type.type
        end
    end
end

class CppFormat
    include ParamLists
    def arg_list(iface, method)
        args = ["#{param_type(iface.type)} obj"]
        method.each_param do |param|
            args << "#{param_type(iface.type)} #{param.name}"
        end
        args
    end
    def name_list(iface, method)
    end
    def type_list(iface, method)
    end
    def param_type(type)
        if type.object? then
            "obref<#{type.type}>"
        else
            type.type
        end
    end
    def return_type(type)
        if type.object? then
            "smartob<#{type.type}>"
        else
            type.type
        end
    end
end

def getreturn(method)
    method.type == "void" ? "" : "return "
end

def getmethodlist(iface)
    ls = []
    iface.each_method {|method| ls << "#{' ' * 16}#{method.name}_"}
    ",\n" + ls.join(",\n")
end

def gettype(node)
    type = node.attributes["type"].to_s
    object = false
    if node.attributes.has_key? "object" then
        object = node.attributes["object"].to_s == "true"
    end
    Type.new(name, object)
end

def getparam(node)
    name = node.attributes["name"].to_s
    type = gettype(node)
    Param.new(name, type)
end

def getmethod(node)
    name = node.attributes["name"].to_s
    qname = nil
    if node.attributes.has_key? "qname" then
        qname = node.attributes["qname"].to_s
    end
    type = gettype(node)
    method = Method_.new(name, qname, type)
    node.elements.each do |child|
        if child.name == "param" then
            param = getparam(child)
            method.push_param(param)
        else
            raise "unknown element '#{x.name}'"
        end
    end
    method
end

def getinterface(pkg, node)
    name = node.attributes["name"].to_s
    interface = Interface.new(pkg, name)
    node.elements.each do |child|
        if child.name == "method" then
            method = getmethod(child)
            interface.push_method(method)
        else
            raise "unknown element '#{x.name}'"
        end
    end
    interface
end

def putcmethod(iface, method)
    format = CFormat.new
    typelist = format.type_list(iface, method).join(", ")
    puts "    #{method.type} (*#{method.name}_)(#{typelist});"
end

def putcdefine(iface, method)
    namelist = getnamelist(method)
    puts <<END

#define #{iface.pkg}_#{method.qname(iface.name)}(#{namelist}) \\
    ((#{iface.cname}*)obj)->vtbl_->#{method.name}_(#{namelist})
END
end

def putinline(iface, method)
    arglist = getarglistref(iface, method)
    namelist = getnamelist(method)
    puts <<END

    inline #{method.type}
    #{method.qname(iface.name)}(#{arglist}) AUG_NOTHROW
    {
        #{iface.cname}* obj(ref.get());
        #{getreturn method}obj->vtbl_->#{method.name}_(#{namelist});
    }
END
end

def putstatic(iface, method)
    arglist = getarglist(iface, method)
    namelist = getnamelistpp(method)
    puts <<END
        static #{method.type}
        #{method.name}_(#{arglist}) AUG_NOTHROW
        {
            T* impl = static_cast<T*>(obj->impl_);
            #{getreturn method}impl->#{method.qname(iface.name)}(#{namelist});
        }
END
end

def putforward(iface, method)
    arglist = getarglistpp(iface, method)
    namelist = getnamelistpp(method)
    qname = method.qname(iface.name)
    puts <<END
        #{method.type}
        #{qname}(#{arglist}) AUG_NOTHROW
        {
            #{getreturn method}impl_.#{qname}(#{namelist});
        }
END
end

def putinterface(iface)
    puts <<END

AUG_OBJECTDECL(#{iface.cname});
struct #{iface.cname}vtbl {
    AUG_OBJECT(#{iface.cname});
END

    iface.each_method {|x| putcmethod iface, x}
    puts "};"
    iface.each_method {|x| putcdefine iface, x}

    puts <<END

#if defined(__cplusplus)
namespace aug {
    template <>
    struct object_traits<#{iface.cname}> {
        typedef #{iface.cname}vtbl vtbl;
        static const char*
        id()
        {
            return #{iface.cname}id;
        }
    };
}

namespace #{iface.pkg} {

    typedef aug::obref<#{iface.cname}> #{iface.name}ref;
END
    iface.each_method {|x| putinline iface, x}
    puts <<END

    template <typename T>
    class #{iface.name} {

        #{iface.cname} #{iface.name}_;

        #{iface.name}(const #{iface.name}&);

        #{iface.name}&
        operator =(const #{iface.name}&);

        static void*
        cast_(#{iface.cname}* obj, const char* id) AUG_NOTHROW
        {
            T* impl = static_cast<T*>(obj->impl_);
            return impl->cast(id).get();
        }
        static int
        incref_(#{iface.cname}* obj) AUG_NOTHROW
        {
            T* impl = static_cast<T*>(obj->impl_);
            return impl->incref();
        }
        static int
        decref_(#{iface.cname}* obj) AUG_NOTHROW
        {
            T* impl = static_cast<T*>(obj->impl_);
            return impl->decref();
        }
END
    iface.each_method {|x| putstatic iface, x}
    puts <<END
        static const #{iface.cname}vtbl*
        vtbl()
        {
            static const #{iface.cname}vtbl local = {
                cast_,
                incref_,
                decref_#{getmethodlist(iface)}
            };
            return &local;
        }
    public:
        explicit
        #{iface.name}(T* impl = 0)
        {
            #{iface.name}_.vtbl_ = vtbl();
            #{iface.name}_.impl_ = impl;
        }
        void
        reset(T* impl)
        {
            #{iface.name}_.impl_ = impl;
        }
        #{iface.cname}*
        get()
        {
            return &#{iface.name}_;
        }
        operator #{iface.name}ref()
        {
            return get();
        }
    };

    template <typename T>
    class basic_#{iface.name} {
        #{iface.name}<basic_#{iface.name}<T> > #{iface.name}_;
        T impl_;
        unsigned refs_;
        explicit
        basic_#{iface.name}(const T& impl)
            : impl_(impl),
              refs_(1)
        {
            #{iface.name}_.reset(this);
        }
    public:
        objectref
        cast(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<#{iface.cname}>(id))
                return #{iface.name}_;
            return null;
        }
        int
        incref() AUG_NOTHROW
        {
            ++refs_;
            return 0;
        }
        int
        decref() AUG_NOTHROW
        {
            if (0 == --refs_)
                delete this;
            return 0;
        }
END
    iface.each_method {|x| putforward iface, x}
    puts <<END
        static aug::smartob<#{iface.cname}>
        create(const T& impl = T())
        {
            basic_#{iface.name}* ptr(new basic_#{iface.name}(impl));
            return aug::object_attach<#{iface.cname}>(ptr->#{iface.name}_);
        }
    };

    template <typename T>
    class scoped_#{iface.name} {
        #{iface.name}<scoped_#{iface.name}<T> > #{iface.name}_;
        T impl_;
    public:
        explicit
        scoped_#{iface.name}(const T& impl = T())
            : impl_(impl)
        {
            #{iface.name}_.reset(this);
        }
        objectref
        cast(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<#{iface.cname}>(id))
                return #{iface.name}_;
            return null;
        }
        int
        incref() AUG_NOTHROW
        {
            return 0;
        }
        int
        decref() AUG_NOTHROW
        {
            return 0;
        }
END
    iface.each_method {|x| putforward iface, x}
    puts <<END
        #{iface.cname}*
        get()
        {
            return #{iface.name}_.get();
        }
        operator #{iface.name}ref()
        {
            return #{iface.name}_;
        }
    };
}
#endif /* __cplusplus */
END
end

def putpackage(file, node)

    name = node.attributes["name"].to_s
    gaurd = "#{name.upcase}_#{file}_H"
    puts <<END
/* -*- c++ -*- */
#ifndef #{gaurd}
#define #{gaurd}

#include "augobj.h"

#if defined(__cplusplus)

#include "augobjpp.hpp"

# if !defined(AUG_NOTHROW)
#  define AUG_NOTHROW
# endif /* !AUG_NOTHROW */

/* For pointer conversions, see 4.10/2:

   "An rvalue of type 'pointer to cv T,' where T is an object type, can be
   converted to an rvalue of type 'pointer to cv void.' The result of
   converting a 'pointer to cv T' to a 'pointer to cv void' points to the
   start of the storage location where the object of type T resides, as if the
   object is a most derived object (1.8) of type T (that is, not a base class
   subobject)."

   So the void * will point to the beginning of your class B. And since B is
   not guaranteed to start with the POD, you may not get what you want. */

namespace aug {
    template <typename T>
    struct object_traits;
}

#endif /* __cplusplus */
END
    node.elements.each do |child|
        if child.name == "verbatim" then
            puts
            puts child.text
        elsif child.name == "interface" then
            iface = getinterface(name, child)
            putinterface(iface)
        else
            raise "unknown element '#{x.name}'"
        end
    end

    puts <<END

#endif /* #{gaurd} */
END
end

file = "INTERFACE"

opts = OptionParser.new do |opts|
    opts.on("-f FILE") do |x|
        file = File.basename(x, ".h").upcase
        file.gsub!(/[^A-Z]/, '_')
    end
end

opts.parse!(ARGV)

if ARGV.empty? then
    doc = Document.new($stdin)
    node = doc.root
    putpackage(file, node)
else
    ARGV.each do |x|
        xml = File.new(x)
        doc = Document.new(xml)
        node = doc.root
        putpackage(file, node)
    end
end
