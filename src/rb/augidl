#!/usr/bin/env ruby
require 'optparse'
require 'rexml/document'

# TODO:
# help attribute.
# getter/setter element.

include REXML

STDOUT.binmode

class Type
    attr_reader :cname
    def initialize(cname, object)
        @cname = cname
        @object = object
    end
    def object?
        @object
    end
end

class Param
    attr_reader :name, :type
    def initialize(name, type)
        @name = name
        @type = type
    end
end

class Method_
    attr_reader :name, :type
    def initialize(name, qname, type)
        @name = name
        @qname = qname
        @type = type
        @params = []
    end
    def each_param(&action)
        @params.each &action
    end
    def push_param(param)
        @params << param
    end
    def qname(iface)
        if @qname.nil? then
            @name + iface
        else
            @qname
        end
    end
end

class Interface
    attr_reader :pkg, :name, :type
    def initialize(pkg, name)
        @pkg = pkg
        @name = name
        @type = Type.new("#{pkg}_#{name}", true)
        @methods = []
    end
    def each_method(&action)
        @methods.each &action
    end
    def push_method(method)
        @methods << method
    end
end

def method_list(iface)
    ls = []
    iface.each_method {|method| ls << "#{' ' * 16}#{method.name}_"}
    ",\n" + ls.join(",\n")
end

module ParamLists
    def arg_list(iface, method)
        args = ["#{param_type(iface.type)} this_"]
        method.each_param do |param|
            args << "#{param_type(param.type)} #{param.name}"
        end
        args
    end
    def name_list(iface, method)
        args = ["this_"]
        method.each_param do |param|
            args << param.name
        end
        args
    end
    def type_list(iface, method)
        args = [param_type(iface.type)]
        method.each_param do |param|
            args << param_type(param.type)
        end
        args
    end
    def return_expr(type, expr)
        type.cname == "void" ? expr : "return #{expr}"
    end
end

def nothis(ls)
    ls.shift
    ls
end

class CFormat
    include ParamLists
    def param_type(type)
        if type.object? then
            "#{type.cname}*"
        else
            type.cname
        end
    end
    def return_type(type)
        if type.object? then
            "#{type.cname}*"
        else
            type.cname
        end
    end
end

class CppFormat
    include ParamLists
    def cname_list(iface, method)
        args = ["this_.get()"]
        method.each_param do |param|
            if param.type.object? then
                args << "#{param.name}.get()"
            else
                args << param.name
            end
        end
        args
    end
    def creturn_expr(type, expr)
        if type.object? then
            "return aug::object_attach<#{type.cname}>(#{expr})";
        else
            type.cname == "void" ? expr : "return #{expr}"
        end
    end
    def param_type(type)
        if type.object? then
            "aug::obref<#{type.cname}>"
        else
            type.cname
        end
    end
    def return_type(type)
        if type.object? then
            "aug::smartob<#{type.cname}>"
        else
            type.cname
        end
    end
end

def gettype(node)
    type = node.attributes["type"].to_s
    object = false
    if node.attributes.has_key? "object" then
        object = node.attributes["object"].to_s !~ /false|no|0/i
    end
    Type.new(type, object)
end

def getparam(node)
    name = node.attributes["name"].to_s
    type = gettype(node)
    Param.new(name, type)
end

def getmethod(node)
    name = node.attributes["name"].to_s
    qname = nil
    if node.attributes.has_key? "qname" then
        qname = node.attributes["qname"].to_s
    end
    type = gettype(node)
    method = Method_.new(name, qname, type)
    node.elements.each do |child|
        if child.name == "param" then
            param = getparam(child)
            method.push_param(param)
        else
            raise "unknown element '#{x.name}'"
        end
    end
    method
end

def getinterface(pkg, node)
    name = node.attributes["name"].to_s
    interface = Interface.new(pkg, name)
    node.elements.each do |child|
        if child.name == "method" then
            method = getmethod(child)
            interface.push_method(method)
        else
            raise "unknown element '#{x.name}'"
        end
    end
    interface
end

def putcmethod(iface, method)
    format = CFormat.new
    types = format.type_list(iface, method).join(", ")
    puts "    #{format.return_type(method.type)} (*#{method.name}_)(#{types});"
end

def putcdefine(iface, method)
    format = CFormat.new
    names = format.name_list(iface, method).join(", ")
    puts <<END

#define #{iface.pkg}_#{method.qname(iface.name)}(#{names}) \\
    ((#{iface.type.cname}*)this_)->vtbl_->#{method.name}_(#{names})
END
end

def putinline(iface, method)
    format = CppFormat.new
    args = format.arg_list(iface, method).join(", ")
    names = format.cname_list(iface, method).join(", ")
    expr = "this_.get()->vtbl_->#{method.name}_(#{names})"
    puts <<END

    inline #{format.return_type(method.type)}
    #{method.qname(iface.name)}(#{args}) AUG_NOTHROW
    {
        #{format.creturn_expr(method.type, expr)};
    }
END
end

def putstatic(iface, method)
    format = CFormat.new
    args = format.arg_list(iface, method).join(", ")
    names = nothis(format.name_list(iface, method)).join(", ")
    expr = "static_cast<T*>(this_->impl_)->#{method.qname(iface.name)}_(#{names})"
    if method.type.object? then
        expr = "aug::incget(#{expr})"
    end
    puts <<END
        static #{format.return_type(method.type)}
        #{method.name}_(#{args}) AUG_NOTHROW
        {
            #{format.return_expr(method.type, expr)};
        }
END
end

def putforward(iface, method)
    format = CppFormat.new
    args = nothis(format.arg_list(iface, method)).join(", ")
    names = nothis(format.name_list(iface, method)).join(", ")
    qname = method.qname(iface.name)
    expr = "this->impl_.#{qname}_(#{names})";
    puts <<END
        #{format.return_type(method.type)}
        #{qname}_(#{args}) AUG_NOTHROW
        {
            #{format.return_expr(method.type, expr)};
        }
END
end

def putinterface(iface)
    puts <<END

AUG_OBJECTDECL(#{iface.type.cname});
struct #{iface.type.cname}vtbl {
    AUG_OBJECT(#{iface.type.cname});
END

    iface.each_method {|x| putcmethod iface, x}
    puts "};"
    iface.each_method {|x| putcdefine iface, x}

    puts <<END

#if defined(__cplusplus)
namespace aug {
    template <>
    struct object_traits<#{iface.type.cname}> {
        typedef #{iface.type.cname}vtbl vtbl;
        static const char*
        id() AUG_NOTHROW
        {
            return #{iface.type.cname}id;
        }
    };
}

namespace #{iface.pkg} {

    typedef aug::obref<#{iface.type.cname}> #{iface.name}ref;
END
    iface.each_method {|x| putinline iface, x}
    puts <<END

    template <typename T>
    class #{iface.name} {

        #{iface.type.cname} #{iface.name}_;

        #{iface.name}(const #{iface.name}&);

        #{iface.name}&
        operator =(const #{iface.name}&);

        static void*
        cast_(#{iface.type.cname}* this_, const char* id) AUG_NOTHROW
        {
            return aug::incget(static_cast<T*>(this_->impl_)->cast_(id));
        }
        static int
        incref_(#{iface.type.cname}* this_) AUG_NOTHROW
        {
            return static_cast<T*>(this_->impl_)->incref_();
        }
        static int
        decref_(#{iface.type.cname}* this_) AUG_NOTHROW
        {
            return static_cast<T*>(this_->impl_)->decref_();
        }
END
    iface.each_method {|x| putstatic iface, x}
    puts <<END
        static const #{iface.type.cname}vtbl*
        vtbl()
        {
            static const #{iface.type.cname}vtbl local = {
                cast_,
                incref_,
                decref_#{method_list(iface)}
            };
            return &local;
        }
    public:
        explicit
        #{iface.name}(T* impl = 0)
        {
            this->#{iface.name}_.vtbl_ = this->vtbl();
            this->#{iface.name}_.impl_ = impl;
        }
        void
        reset(T* impl)
        {
            this->#{iface.name}_.impl_ = impl;
        }
        #{iface.type.cname}*
        get() AUG_NOTHROW
        {
            return &this->#{iface.name}_;
        }
        operator aug::obref<#{iface.type.cname}>() AUG_NOTHROW
        {
            return this->get();
        }
    };

    template <typename T>
    class basic_#{iface.name} {
        #{iface.name}<basic_#{iface.name}<T> > #{iface.name}_;
        T impl_;
        int refs_;
        explicit
        basic_#{iface.name}(const T& impl)
            : impl_(impl),
              refs_(1)
        {
            this->#{iface.name}_.reset(this);
        }
    public:
        aug::smartob<aug_object>
        cast_(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<#{iface.type.cname}>(id))
                return aug::object_incref<aug_object>(this->#{iface.name}_);
            return null;
        }
        int
        incref_() AUG_NOTHROW
        {
            assert(0 < this->refs_);
            ++this->refs_;
            return 0;
        }
        int
        decref_() AUG_NOTHROW
        {
            assert(0 < this->refs_);
            if (0 == --this->refs_)
                delete this;
            return 0;
        }
END
    iface.each_method {|x| putforward iface, x}
    puts <<END
        static aug::smartob<#{iface.type.cname}>
        create(const T& impl = T())
        {
            basic_#{iface.name}* ptr(new basic_#{iface.name}(impl));
            return aug::object_attach<#{iface.type.cname}>(ptr->#{iface.name}_);
        }
    };

    template <typename T>
    class scoped_#{iface.name} {
        #{iface.name}<scoped_#{iface.name}<T> > #{iface.name}_;
        T impl_;
    public:
        explicit
        scoped_#{iface.name}(const T& impl = T())
            : impl_(impl)
        {
            this->#{iface.name}_.reset(this);
        }
        aug::smartob<aug_object>
        cast_(const char* id) AUG_NOTHROW
        {
            if (aug::equalid<aug_object>(id) || aug::equalid<#{iface.type.cname}>(id))
                return aug::object_incref<aug_object>(this->#{iface.name}_);
            return null;
        }
        int
        incref_() AUG_NOTHROW
        {
            return 0;
        }
        int
        decref_() AUG_NOTHROW
        {
            return 0;
        }
END
    iface.each_method {|x| putforward iface, x}
    puts <<END
        aug_object*
        base() AUG_NOTHROW
        {
            return aug::obref<aug_object>(this->#{iface.name}_).get();
        }
        #{iface.type.cname}*
        get() AUG_NOTHROW
        {
            return this->#{iface.name}_.get();
        }
        operator aug::obref<#{iface.type.cname}>() AUG_NOTHROW
        {
            return this->#{iface.name}_;
        }
    };
}
#endif /* __cplusplus */
END
end

def putpackage(file, node)

    name = node.attributes["name"].to_s
    gaurd = "#{name.upcase}_#{file}_H"
    puts <<END
/* -*- c++ -*- */
/* Automatically generated by #{File.basename($0)} */
/* at #{Time.now} */

#ifndef #{gaurd}
#define #{gaurd}

#include "augobj.h"

#if defined(__cplusplus)

#include "augobjpp.hpp"

# if !defined(AUG_NOTHROW)
#  define AUG_NOTHROW
# endif /* !AUG_NOTHROW */

/* For pointer conversions, see 4.10/2:

   "An rvalue of type 'pointer to cv T,' where T is an object type, can be
   converted to an rvalue of type 'pointer to cv void.' The result of
   converting a 'pointer to cv T' to a 'pointer to cv void' points to the
   start of the storage location where the object of type T resides, as if the
   object is a most derived object (1.8) of type T (that is, not a base class
   subobject)."

   So the void * will point to the beginning of your class B. And since B is
   not guaranteed to start with the POD, you may not get what you want. */

namespace aug {
    template <typename T>
    struct object_traits;
}

#endif /* __cplusplus */
END
    node.elements.each do |child|
        case child.name
            when "anglincl"
                puts "\#include <#{child.text}>"
            when "interface"
                iface = getinterface(name, child)
                putinterface(iface)
            when "quotincl"
                puts "\#include \"#{child.text}\""
            when "verbatim"
                puts child.text
            else
                raise "unknown element '#{x.name}'"
        end
    end

    puts <<END

#endif /* #{gaurd} */
END
end

file = "INTERFACE"

opts = OptionParser.new do |opts|
    opts.on("-f FILE") do |x|
        file = File.basename(x, ".h").upcase
        file.gsub!(/[^A-Z]/, '_')
    end
end

opts.parse!(ARGV)

if ARGV.empty? then
    doc = Document.new($stdin)
    node = doc.root
    putpackage(file, node)
else
    ARGV.each do |x|
        xml = File.new(x)
        doc = Document.new(xml)
        node = doc.root
        putpackage(file, node)
    end
end
