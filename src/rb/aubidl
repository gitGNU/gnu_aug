#!/usr/bin/env ruby
require 'optparse'
require 'rexml/document'

# TODO:
# help attribute.
# getter/setter element.

include REXML

STDOUT.binmode

class AnglIncl
    attr_reader :text
    def initialize(text)
        @text = text
    end
    def accept(v)
        v.visit_anglincl(self)
    end
    def AnglIncl.parse(node)
        AnglIncl.new(node.text)
    end
end

class QuotIncl
    attr_reader :text
    def initialize(text)
        @text = text
    end
    def accept(v)
        v.visit_quotincl(self)
    end
    def QuotIncl.parse(node)
        QuotIncl.new(node.text)
    end
end

class Verbatim
    attr_reader :text
    def initialize(text)
        @text = text
    end
    def accept(v)
        v.visit_verbatim(self)
    end
    def Verbatim.parse(node)
        Verbatim.new(node.text)
    end
end

class Type
    attr_reader :cname
    def initialize(cname, object)
        @cname = cname
        @object = object
    end
    def object?
        @object
    end
    def Type.parse(node)
        type = node.attributes["type"].to_s
        object = false
        if node.attributes.has_key? "object" then
            object = node.attributes["object"].to_s !~ /false|no|0/i
        end
        Type.new(type, object)
    end
end

class Param
    attr_reader :name, :type
    def initialize(name, type)
        @name = name
        @type = type
    end
    def Param.parse(node)
        name = node.attributes["name"].to_s
        type = Type.parse(node)
        Param.new(name, type)
    end
end

class Method_
    attr_reader :name, :type, :qname
    def initialize(iface, name, type, qname)
        @name = name
        @type = type
        if qname.nil? then
            @qname = name + iface
        else
            @qname = qname
        end
        @params = []
    end
    def each_param(&action)
        @params.each &action
    end
    def push_param(param)
        @params << param
    end
    def Method_.parse(iface, node)
        name = node.attributes["name"].to_s
        type = Type.parse(node)
        qname = nil
        if node.attributes.has_key? "qname" then
            qname = node.attributes["qname"].to_s
        end
        method = Method_.new(iface, name, type, qname)
        node.elements.each do |child|
            if child.name == "param" then
                param = Param.parse(child)
                method.push_param(param)
            else
                raise "unknown element '#{x.name}'"
            end
        end
        method
    end
end

def method_list(iface)
    ls = []
    iface.each_method {|method| ls << "#{' ' * 16}#{method.name}_"}
    ",\n" + ls.join(",\n")
end

class Interface
    attr_reader :pkg, :name, :type
    def initialize(pkg, name)
        @pkg = pkg
        @name = name
        @type = Type.new("#{pkg}_#{name}", true)
        @methods = []
    end
    def each_method(&action)
        @methods.each &action
    end
    def push_method(method)
        @methods << method
    end
    def accept(v)
        v.visit_interface(self)
    end
    def Interface.parse(pkg, node)
        name = node.attributes["name"].to_s
        interface = Interface.new(pkg, name)
        node.elements.each do |child|
            if child.name == "method" then
                method = Method_.parse(name, child)
                interface.push_method(method)
            else
                raise "unknown element '#{x.name}'"
            end
        end
        interface
    end
end

class Package
    attr_reader :name, :elements
    def initialize(name)
        @name = name
        @elements = []
    end
    def each_element(&action)
        @elements.each &action
    end
    def push_element(elem)
        @elements << elem
    end
    def each_accept(v)
        @elements.each {|elem| elem.accept(v)}
    end
    def Package.parse(node)
        name = node.attributes["name"].to_s
        package = Package.new(name)
        node.elements.each do |child|
            case child.name
            when "anglincl"
                package.push_element(AnglIncl.parse(child))
            when "interface"
                package.push_element(Interface.parse(name, child))
            when "quotincl"
                package.push_element(QuotIncl.parse(child))
            when "verbatim"
                package.push_element(Verbatim.parse(child))
            else
                raise "unknown element '#{x.name}'"
            end
        end
        package
    end
end

file = "INTERFACE"
opts = OptionParser.new do |opts|
    opts.on("-f FILE") do |x|
        file = File.basename(x, ".h").upcase
        file.gsub!(/[^A-Z]/, '_')
    end
end

opts.parse!(ARGV)

package = nil
if ARGV.empty? then
    doc = Document.new($stdin)
    node = doc.root
    package = Package.parse(node)
else
    ARGV.each do |x|
        xml = File.new(x)
        doc = Document.new(xml)
        node = doc.root
        package = Package.parse(node)
    end
end

module ParamLists
    def arg_list(iface, method)
        args = ["#{param_type(iface.type)} this_"]
        method.each_param do |param|
            args << "#{param_type(param.type)} #{param.name}"
        end
        args
    end
    def name_list(iface, method)
        args = ["this_"]
        method.each_param do |param|
            args << param.name
        end
        args
    end
    def type_list(iface, method)
        args = [param_type(iface.type)]
        method.each_param do |param|
            args << param_type(param.type)
        end
        args
    end
    def return_expr(type, expr)
        type.cname == "void" ? expr : "return #{expr}"
    end
end

class CFormat
    include ParamLists
    def param_type(type)
        if type.object? then
            "#{type.cname}*"
        else
            type.cname
        end
    end
    def return_type(type)
        if type.object? then
            "#{type.cname}*"
        else
            type.cname
        end
    end
end

class CppFormat
    include ParamLists
    def cname_list(iface, method)
        args = ["this_.get()"]
        method.each_param do |param|
            if param.type.object? then
                args << "#{param.name}.get()"
            else
                args << param.name
            end
        end
        args
    end
    def creturn_expr(type, expr)
        if type.object? then
            "return aub::object_attach<#{type.cname}>(#{expr})";
        else
            type.cname == "void" ? expr : "return #{expr}"
        end
    end
    def param_type(type)
        if type.object? then
            "aub::obref<#{type.cname}>"
        else
            type.cname
        end
    end
    def return_type(type)
        if type.object? then
            "aub::smartob<#{type.cname}>"
        else
            type.cname
        end
    end
end

def nothis(ls)
    ls.shift
    ls
end

def putcmethod(iface, method)
    format = CFormat.new
    types = format.type_list(iface, method).join(", ")
    puts "    #{format.return_type(method.type)} (*#{method.name}_)(#{types});"
end

def putcdefine(iface, method)
    format = CFormat.new
    names = format.name_list(iface, method).join(", ")
    puts <<END

#define #{iface.pkg}_#{method.qname}(#{names}) \\
    ((#{iface.type.cname}*)this_)->vtbl_->#{method.name}_(#{names})
END
end

def putinline(iface, method)
    format = CppFormat.new
    args = format.arg_list(iface, method).join(", ")
    names = format.cname_list(iface, method).join(", ")
    expr = "this_.get()->vtbl_->#{method.name}_(#{names})"
    puts <<END

    inline #{format.return_type(method.type)}
    #{method.qname}(#{args}) AUB_NOTHROW
    {
        #{format.creturn_expr(method.type, expr)};
    }
END
end

def putstatic(iface, method)
    format = CFormat.new
    args = format.arg_list(iface, method).join(", ")
    names = nothis(format.name_list(iface, method)).join(", ")
    expr = "static_cast<T*>(this_->impl_)->#{method.qname}_(#{names})"
    if method.type.object? then
        expr = "aub::incget(#{expr})"
    end
    puts <<END
        static #{format.return_type(method.type)}
        #{method.name}_(#{args}) AUB_NOTHROW
        {
            #{format.return_expr(method.type, expr)};
        }
END
end

def putforward(iface, method)
    format = CppFormat.new
    args = nothis(format.arg_list(iface, method)).join(", ")
    names = nothis(format.name_list(iface, method)).join(", ")
    expr = "this->impl_.#{method.qname}_(#{names})";
    puts <<END
        #{format.return_type(method.type)}
        #{method.qname}_(#{args}) AUB_NOTHROW
        {
            #{format.return_expr(method.type, expr)};
        }
END
end

class Visitor
    def visit_anglincl(elem)
        puts "\#include <#{elem.text}>"
    end
    def visit_interface(elem)
        puts <<END

/**
 * @defgroup #{elem.type.cname} #{elem.type.cname}
 *
 * @ingroup Object
 *
 * @{
 */

AUB_INTERFACE(#{elem.type.cname});

struct #{elem.type.cname}vtbl {
    AUB_VTBL(#{elem.type.cname});
END
        elem.each_method {|x| putcmethod elem, x}
        puts "};"
        elem.each_method {|x| putcdefine elem, x}
        puts <<END

/** @} */

#if defined(__cplusplus)
namespace aub {
    template <>
    struct object_traits<#{elem.type.cname}> {
        typedef #{elem.type.cname}vtbl vtbl;
        static const char*
        id() AUB_NOTHROW
        {
            return #{elem.type.cname}id;
        }
    };
}

namespace #{elem.pkg} {

    typedef aub::obref<#{elem.type.cname}> #{elem.name}ref;
END
        elem.each_method {|x| putinline elem, x}
        puts <<END

    template <typename T>
    class #{elem.name} {

        #{elem.type.cname} #{elem.name}_;

        #{elem.name}(const #{elem.name}&);

        #{elem.name}&
        operator =(const #{elem.name}&);

        static void*
        cast_(#{elem.type.cname}* this_, const char* id) AUB_NOTHROW
        {
            return aub::incget(static_cast<T*>(this_->impl_)->cast_(id));
        }
        static int
        retain_(#{elem.type.cname}* this_) AUB_NOTHROW
        {
            return static_cast<T*>(this_->impl_)->retain_();
        }
        static int
        release_(#{elem.type.cname}* this_) AUB_NOTHROW
        {
            return static_cast<T*>(this_->impl_)->release_();
        }
END
        elem.each_method {|x| putstatic elem, x}
        puts <<END
        static const #{elem.type.cname}vtbl*
        vtbl()
        {
            static const #{elem.type.cname}vtbl local = {
                cast_,
                retain_,
                release_#{method_list(elem)}
            };
            return &local;
        }
    public:
        explicit
        #{elem.name}(T* impl = 0)
        {
            this->#{elem.name}_.vtbl_ = this->vtbl();
            this->#{elem.name}_.impl_ = impl;
        }
        void
        reset(T* impl)
        {
            this->#{elem.name}_.impl_ = impl;
        }
        #{elem.type.cname}*
        get() AUB_NOTHROW
        {
            return &this->#{elem.name}_;
        }
        operator aub::obref<#{elem.type.cname}>() AUB_NOTHROW
        {
            return this->get();
        }
    };

    template <typename T>
    class basic_#{elem.name} {
        #{elem.name}<basic_#{elem.name}<T> > #{elem.name}_;
        T impl_;
        int refs_;
        explicit
        basic_#{elem.name}(const T& impl)
            : impl_(impl),
              refs_(1)
        {
            this->#{elem.name}_.reset(this);
        }
    public:
        aub::smartob<aub_object>
        cast_(const char* id) AUB_NOTHROW
        {
            if (aub::equalid<aub_object>(id) || aub::equalid<#{elem.type.cname}>(id))
                return aub::object_retain<aub_object>(this->#{elem.name}_);
            return null;
        }
        int
        retain_() AUB_NOTHROW
        {
            assert(0 < this->refs_);
            ++this->refs_;
            return 0;
        }
        int
        release_() AUB_NOTHROW
        {
            assert(0 < this->refs_);
            if (0 == --this->refs_)
                delete this;
            return 0;
        }
END
        elem.each_method {|x| putforward elem, x}
        puts <<END
        static aub::smartob<#{elem.type.cname}>
        create(const T& impl = T())
        {
            basic_#{elem.name}* ptr(new basic_#{elem.name}(impl));
            return aub::object_attach<#{elem.type.cname}>(ptr->#{elem.name}_);
        }
    };

    template <typename T>
    class scoped_#{elem.name} {
        #{elem.name}<scoped_#{elem.name}<T> > #{elem.name}_;
        T impl_;
    public:
        explicit
        scoped_#{elem.name}(const T& impl = T())
            : impl_(impl)
        {
            this->#{elem.name}_.reset(this);
        }
        aub::smartob<aub_object>
        cast_(const char* id) AUB_NOTHROW
        {
            if (aub::equalid<aub_object>(id) || aub::equalid<#{elem.type.cname}>(id))
                return aub::object_retain<aub_object>(this->#{elem.name}_);
            return null;
        }
        int
        retain_() AUB_NOTHROW
        {
            return 0;
        }
        int
        release_() AUB_NOTHROW
        {
            return 0;
        }
END
        elem.each_method {|x| putforward elem, x}
        puts <<END
        aub_object*
        base() AUB_NOTHROW
        {
            return aub::obref<aub_object>(this->#{elem.name}_).get();
        }
        #{elem.type.cname}*
        get() AUB_NOTHROW
        {
            return this->#{elem.name}_.get();
        }
        operator aub::obref<#{elem.type.cname}>() AUB_NOTHROW
        {
            return this->#{elem.name}_;
        }
    };
}
#endif /* __cplusplus */
END
    end
    def visit_quotincl(elem)
        puts "\#include \"#{elem.text}\""
    end
    def visit_verbatim(elem)
        puts elem.text
    end
end

gaurd = "#{package.name.upcase}_#{file}_H"
puts <<END
/* -*- c++ -*- */
/* Automatically generated by #{File.basename($0)} */
/* at #{Time.now} */

#ifndef #{gaurd}
#define #{gaurd}

#include "aub.h"

#if defined(__cplusplus)

#include "aubpp.hpp"

# if !defined(AUB_NOTHROW)
#  define AUB_NOTHROW
# endif /* !AUB_NOTHROW */

namespace aub {
    template <typename T>
    struct object_traits;
}

#endif /* __cplusplus */
END

package.each_accept(Visitor.new)

puts <<END

#endif /* #{gaurd} */
END
