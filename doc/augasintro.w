% modtest: An example Augas module by Mark Aylett

\nocon % omit table of contents
\datethis % print date on listing
\def\SPARC{SPARC\-\kern.1em station}

@s std int
@s string int

@s augas int
@s basic_factory int
@s basic_module int
@s basic_serv int
@s object int
@s serv int
@s serv_base int
@s user int

@* Introduction.  Augas is a network application server.

Modules are physical components which are dynamically loaded into the host
environment provided by the application server.

Such a system allows features that run horizonal, across many services, to be
implemented in modules.

Application servers help to promote component rather than source-level reuse.

Each Module can provide one or more services.

Services can be wired together at configuration time rather than compile time.

The application server presents a uniform interface to system administrators,
regardless of the services provides.

A good example of this is the Python module which provides Python bindings to
allow services to be implemented in Python.

The application server manages many common and error-prone tasks associated
with network servers, including:

\item{$\bullet$} portability

\item{$\bullet$} native daemonisation

\item{$\bullet$} log rotation

\item{$\bullet$} threading model

\item{$\bullet$} event multiplexing

\item{$\bullet$} non-blocking |connect()| calls

\item{$\bullet$} efficient timers

Augas runs natively on both Linux and Windows.

On Windows, it does not require a porting layer, such as Cygwin, to function.

It also adheres as closely as possible to the conventions of the target
platform.  daemonisation, for example, takes the form of an NT service on
Windows.

The application server uses an event-based model to de-multiplex signal,
socket, timer and custom event activity.

All module calls are dispatched from the event thread.

The application server can provide numerous services simultaneously on a
single thread.

A multi-threaded environment is not imposed upon a service.

Log rotation has also been designed to operate on the event thread.

@ Services.  A single application server instance may host many services.

@ Modules.  Each service is managed by a module; each module may manage
several services.  Module are physical components.

Modules extend and adapt the host environment provided by the application
server.

A Python module is contained in the standard distribution.

@ Host.  The host environment exposes several class of object that are common
to network servers.

@ Logging.  TODO

@ Config.

Modules and Services are wired together in the configuration file.

@ Events.  TODO

Services can communicate using a custom event model.  A service can respond to
events generated by a service implemented in an entirely different language.

@ Sockets.  TODO

@ Timers.

Timers are especially useful for implementing heartbeat mechanisms common to
many protocols.

@ Test section.  This is a test.

@c
@<include augas header@>@/
@<implement service@>@/
@<declare export table@>

@ The \.{<augaspp.hpp>} provides a set of utiliy functions and classes
designed to facilitate module implementations in c++.  Modules can, however,
just as easily be written in c.  A c implementation would use the
\.{<augas.h>} header.

@<include...@>=
#include <augaspp.hpp>

@ Services must implement the |serv_base| interface.  Stub implementations to
most of the pure virtual functions are provided by |basic_serv|.  For
convenience, |serv| is derived from |basic_serv|.

@<implement...@>=
using namespace augas;
using namespace std;@/

namespace {@/
struct serv : basic_serv {@/
@<start service@>@/
@<accept connection@>@/
@<cleanup on disconnect@>@/
@<process data@>@/
@<handle timer expiry@>@/
};@/
}

@ Here is the main program.

@<declare...@>=
typedef basic_module<basic_factory<serv> > module;@/
AUGAS_MODULE(module::init, module::term)

@ TODO

@<start...@>=
bool
do_start(const char* sname)
{
  writelog(AUGAS_LOGINFO, "starting service [%s]", sname);
  const char* serv = augas::getenv("session.intro.serv");
  if (!serv)
    return false;
  tcplisten(sname, "0.0.0.0", serv);
  return true;
}

@ TODO

@<accept...@>=
bool
do_accept(object& sock, const char* addr, unsigned short port)
{
  sock.setuser(new string());
  send(sock, "hello\r\n", 7);
  setrwtimer(sock, 15000, AUGAS_TIMRD);
  return true;
}

@ Cleanup any state associated with the socket.

@<cleanup...@>=
void
do_closed(const object& sock)
{
  delete sock.user<string>();
}

@ TODO

@<process data...@>=
void
do_data(const object& sock, const char* buf, size_t size)
{
  string& line = *sock.user<string>();

  string tail(buf, size);
  while (shift(line, tail)) {
    @<strip eol sequence@>;
    @<prepare response@>;
    @<send response@>;
  }
}

@ No data has arrived for 15 seconds so the connection is shutdown (a FIN is
sent).  Any inflight data will still be delivered to the Service.

@<handle timer...@>=
void
do_rdexpire(const object& sock, unsigned& ms)
{
  shutdown(sock);
}

@ Remove any trailing carriage-return character from the end of the line.

@<strip...@>=
if (!line.empty() && '\r' == line[line.size() - 1])@/
  line.resize(line.size() - 1);

@ Reverse the line.  CR/LF pairs are used as the end-of-line sequence.  This
is common in many text-based protocols, such as POP3 and SMTP.

@<prepare...@>=
reverse(line.begin(), line.end());
line += "\r\n";

@ The |send()| function buffers the data to be written.  Clear the line in
anticipation of the next.

@<send...@>=
send(sock, line.c_str(), line.size());
line.clear();

@* Index.
Here is a list of the identifiers used, and where they appear. Underlined
entries indicate the place of definition. Error messages are also shown.
